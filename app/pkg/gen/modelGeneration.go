package gen

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/token"
	"gomes/pkg/util"

	"golang.org/x/tools/go/packages"
)

type ModelGeneration struct {
	output                  string       `json:"output"`
	packageName             string       `json:"packageName"`
	modelList               []structItem `json:"modelList"`
	excludedFromDaoCreation []string     `json:"excludedFromDaoCreation"`
	modelsToGenerate        map[string][]string
	generatedCode           string
}

type structItem struct {
	Path           string   `json:"path"`
	ExcludedModels []string `json:"excludedModels"`
}

func NewModelGenerationFromString(content string) (*ModelGeneration, error) {

	var modelGen ModelGeneration
	err := json.Unmarshal([]byte(content), &modelGen)
	if err != nil {
		return nil, err
	}

	modelGen.modelsToGenerate = make(map[string][]string)

	return &modelGen, nil
}

func NewModelGenerationFromFile(filePath string) (*ModelGeneration, error) {
	content, err := util.ReadFromFile(filePath)
	if err != nil {
		return nil, err
	}
	return NewModelGenerationFromString(content)
}

func (mg *ModelGeneration) SetModelsToGenerateAndWriteToFile() error {
	err := mg.SetModelsToGenerate()
	if err != nil {
		return err
	}
	mg.GenerateModelReferenceCode()

	err = util.WriteToFile(mg.output, mg.generatedCode)

	return err

}

// GetPackageStructsFromPath extracts struct names and their references from a given package path.
func (mg *ModelGeneration) SetModelsToGenerate() error {

	cfg := &packages.Config{
		Mode: packages.NeedSyntax | packages.NeedTypes | packages.NeedTypesInfo,
	}

	for _, model := range mg.modelList {
		fmt.Println(model)
		pkgs, err := packages.Load(cfg, model.Path)
		if err != nil {
			return fmt.Errorf("error: %w", err)
		}
		if len(pkgs) == 0 {
			return fmt.Errorf("no packages found")
		}

		for _, pkg := range pkgs {
			packageName := pkg.Types.Name()
			for _, syntax := range pkg.Syntax {
				for _, decl := range syntax.Decls {
					genDecl, ok := decl.(*ast.GenDecl)
					if !ok || genDecl.Tok != token.TYPE {
						continue
					}
					for _, spec := range genDecl.Specs {
						typeSpec, isStruct := isStruct(spec)

						if !isStruct {
							continue
						}

						structName := typeSpec.Name.Name
						for _, excludedModel := range model.ExcludedModels {
							if structName != excludedModel {
								mg.modelsToGenerate[model.Path] = append(mg.modelsToGenerate[model.Path], packageName+"."+structName)
							}
						}

					}
				}
			}
		}

	}

	return nil
}

func isStruct(spec ast.Spec) (*ast.TypeSpec, bool) {
	typeSpec, ok := spec.(*ast.TypeSpec)
	if !ok {
		return nil, false
	}
	_, ok = typeSpec.Type.(*ast.StructType)
	if !ok {
		return nil, false
	}

	return typeSpec, true

}

// GenerateCode generates code based on the struct references.
func (mg *ModelGeneration) GenerateModelReferenceCode() {
	code := "// Code generated by gomes. DO NOT EDIT.\n"
	code += "// Code generated by gomes. DO NOT EDIT.\n"
	code += "// Code generated by gomes. DO NOT EDIT.\n\n"
	code += "package " + mg.packageName + "\n\n"
	code += "import (\n"
	for packagePath := range mg.modelsToGenerate {
		code += "\"" + packagePath + "\"\n"
	}
	code += ")\n\n"
	code += "var GeneratedModelReferences = map[string]interface{}{\n"
	for _, models := range mg.modelsToGenerate {
		for _, model := range models {
			code += fmt.Sprintf("\t\"%s\": %s{},\n", model, model)
		}

	}
	code += "}\n"
	mg.generatedCode = code
}
