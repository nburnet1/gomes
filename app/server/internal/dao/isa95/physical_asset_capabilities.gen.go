// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package isa95

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gomes/server/internal/model/isa95"
)

func newPhysicalAssetCapability(db *gorm.DB, opts ...gen.DOOption) physicalAssetCapability {
	_physicalAssetCapability := physicalAssetCapability{}

	_physicalAssetCapability.physicalAssetCapabilityDo.UseDB(db, opts...)
	_physicalAssetCapability.physicalAssetCapabilityDo.UseModel(&isa95.PhysicalAssetCapability{})

	tableName := _physicalAssetCapability.physicalAssetCapabilityDo.TableName()
	_physicalAssetCapability.ALL = field.NewAsterisk(tableName)
	_physicalAssetCapability.ID = field.NewUint(tableName, "id")
	_physicalAssetCapability.CreatedAt = field.NewTime(tableName, "created_at")
	_physicalAssetCapability.UpdatedAt = field.NewTime(tableName, "updated_at")
	_physicalAssetCapability.DeletedAt = field.NewField(tableName, "deleted_at")
	_physicalAssetCapability.PhysicalAssetClassID = field.NewUint(tableName, "physical_asset_class_id")
	_physicalAssetCapability.PhysicalAssetID = field.NewUint(tableName, "physical_asset_id")
	_physicalAssetCapability.Description = field.NewString(tableName, "description")
	_physicalAssetCapability.CapabilityType = field.NewString(tableName, "capability_type")
	_physicalAssetCapability.Reason = field.NewString(tableName, "reason")
	_physicalAssetCapability.ConfidenceFactor = field.NewString(tableName, "confidence_factor")
	_physicalAssetCapability.LevelID = field.NewUint(tableName, "level_id")
	_physicalAssetCapability.UseID = field.NewUint(tableName, "use_id")
	_physicalAssetCapability.StartTime = field.NewTime(tableName, "start_time")
	_physicalAssetCapability.EndTime = field.NewTime(tableName, "end_time")
	_physicalAssetCapability.Quantity = field.NewUint(tableName, "quantity")
	_physicalAssetCapability.MeasurementID = field.NewUint(tableName, "measurement_id")

	_physicalAssetCapability.fillFieldMap()

	return _physicalAssetCapability
}

type physicalAssetCapability struct {
	physicalAssetCapabilityDo

	ALL                  field.Asterisk
	ID                   field.Uint
	CreatedAt            field.Time
	UpdatedAt            field.Time
	DeletedAt            field.Field
	PhysicalAssetClassID field.Uint
	PhysicalAssetID      field.Uint
	Description          field.String
	CapabilityType       field.String
	Reason               field.String
	ConfidenceFactor     field.String
	LevelID              field.Uint
	UseID                field.Uint
	StartTime            field.Time
	EndTime              field.Time
	Quantity             field.Uint
	MeasurementID        field.Uint

	fieldMap map[string]field.Expr
}

func (p physicalAssetCapability) Table(newTableName string) *physicalAssetCapability {
	p.physicalAssetCapabilityDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p physicalAssetCapability) As(alias string) *physicalAssetCapability {
	p.physicalAssetCapabilityDo.DO = *(p.physicalAssetCapabilityDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *physicalAssetCapability) updateTableName(table string) *physicalAssetCapability {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewUint(table, "id")
	p.CreatedAt = field.NewTime(table, "created_at")
	p.UpdatedAt = field.NewTime(table, "updated_at")
	p.DeletedAt = field.NewField(table, "deleted_at")
	p.PhysicalAssetClassID = field.NewUint(table, "physical_asset_class_id")
	p.PhysicalAssetID = field.NewUint(table, "physical_asset_id")
	p.Description = field.NewString(table, "description")
	p.CapabilityType = field.NewString(table, "capability_type")
	p.Reason = field.NewString(table, "reason")
	p.ConfidenceFactor = field.NewString(table, "confidence_factor")
	p.LevelID = field.NewUint(table, "level_id")
	p.UseID = field.NewUint(table, "use_id")
	p.StartTime = field.NewTime(table, "start_time")
	p.EndTime = field.NewTime(table, "end_time")
	p.Quantity = field.NewUint(table, "quantity")
	p.MeasurementID = field.NewUint(table, "measurement_id")

	p.fillFieldMap()

	return p
}

func (p *physicalAssetCapability) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *physicalAssetCapability) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 16)
	p.fieldMap["id"] = p.ID
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
	p.fieldMap["deleted_at"] = p.DeletedAt
	p.fieldMap["physical_asset_class_id"] = p.PhysicalAssetClassID
	p.fieldMap["physical_asset_id"] = p.PhysicalAssetID
	p.fieldMap["description"] = p.Description
	p.fieldMap["capability_type"] = p.CapabilityType
	p.fieldMap["reason"] = p.Reason
	p.fieldMap["confidence_factor"] = p.ConfidenceFactor
	p.fieldMap["level_id"] = p.LevelID
	p.fieldMap["use_id"] = p.UseID
	p.fieldMap["start_time"] = p.StartTime
	p.fieldMap["end_time"] = p.EndTime
	p.fieldMap["quantity"] = p.Quantity
	p.fieldMap["measurement_id"] = p.MeasurementID
}

func (p physicalAssetCapability) clone(db *gorm.DB) physicalAssetCapability {
	p.physicalAssetCapabilityDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p physicalAssetCapability) replaceDB(db *gorm.DB) physicalAssetCapability {
	p.physicalAssetCapabilityDo.ReplaceDB(db)
	return p
}

type physicalAssetCapabilityDo struct{ gen.DO }

func (p physicalAssetCapabilityDo) Debug() *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Debug())
}

func (p physicalAssetCapabilityDo) WithContext(ctx context.Context) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p physicalAssetCapabilityDo) ReadDB() *physicalAssetCapabilityDo {
	return p.Clauses(dbresolver.Read)
}

func (p physicalAssetCapabilityDo) WriteDB() *physicalAssetCapabilityDo {
	return p.Clauses(dbresolver.Write)
}

func (p physicalAssetCapabilityDo) Session(config *gorm.Session) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Session(config))
}

func (p physicalAssetCapabilityDo) Clauses(conds ...clause.Expression) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p physicalAssetCapabilityDo) Returning(value interface{}, columns ...string) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p physicalAssetCapabilityDo) Not(conds ...gen.Condition) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p physicalAssetCapabilityDo) Or(conds ...gen.Condition) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p physicalAssetCapabilityDo) Select(conds ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p physicalAssetCapabilityDo) Where(conds ...gen.Condition) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p physicalAssetCapabilityDo) Order(conds ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p physicalAssetCapabilityDo) Distinct(cols ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p physicalAssetCapabilityDo) Omit(cols ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p physicalAssetCapabilityDo) Join(table schema.Tabler, on ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p physicalAssetCapabilityDo) LeftJoin(table schema.Tabler, on ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p physicalAssetCapabilityDo) RightJoin(table schema.Tabler, on ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p physicalAssetCapabilityDo) Group(cols ...field.Expr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p physicalAssetCapabilityDo) Having(conds ...gen.Condition) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p physicalAssetCapabilityDo) Limit(limit int) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p physicalAssetCapabilityDo) Offset(offset int) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p physicalAssetCapabilityDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p physicalAssetCapabilityDo) Unscoped() *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Unscoped())
}

func (p physicalAssetCapabilityDo) Create(values ...*isa95.PhysicalAssetCapability) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p physicalAssetCapabilityDo) CreateInBatches(values []*isa95.PhysicalAssetCapability, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p physicalAssetCapabilityDo) Save(values ...*isa95.PhysicalAssetCapability) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p physicalAssetCapabilityDo) First() (*isa95.PhysicalAssetCapability, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*isa95.PhysicalAssetCapability), nil
	}
}

func (p physicalAssetCapabilityDo) Take() (*isa95.PhysicalAssetCapability, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*isa95.PhysicalAssetCapability), nil
	}
}

func (p physicalAssetCapabilityDo) Last() (*isa95.PhysicalAssetCapability, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*isa95.PhysicalAssetCapability), nil
	}
}

func (p physicalAssetCapabilityDo) Find() ([]*isa95.PhysicalAssetCapability, error) {
	result, err := p.DO.Find()
	return result.([]*isa95.PhysicalAssetCapability), err
}

func (p physicalAssetCapabilityDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*isa95.PhysicalAssetCapability, err error) {
	buf := make([]*isa95.PhysicalAssetCapability, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p physicalAssetCapabilityDo) FindInBatches(result *[]*isa95.PhysicalAssetCapability, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p physicalAssetCapabilityDo) Attrs(attrs ...field.AssignExpr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p physicalAssetCapabilityDo) Assign(attrs ...field.AssignExpr) *physicalAssetCapabilityDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p physicalAssetCapabilityDo) Joins(fields ...field.RelationField) *physicalAssetCapabilityDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p physicalAssetCapabilityDo) Preload(fields ...field.RelationField) *physicalAssetCapabilityDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p physicalAssetCapabilityDo) FirstOrInit() (*isa95.PhysicalAssetCapability, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*isa95.PhysicalAssetCapability), nil
	}
}

func (p physicalAssetCapabilityDo) FirstOrCreate() (*isa95.PhysicalAssetCapability, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*isa95.PhysicalAssetCapability), nil
	}
}

func (p physicalAssetCapabilityDo) FindByPage(offset int, limit int) (result []*isa95.PhysicalAssetCapability, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p physicalAssetCapabilityDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p physicalAssetCapabilityDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p physicalAssetCapabilityDo) Delete(models ...*isa95.PhysicalAssetCapability) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *physicalAssetCapabilityDo) withDO(do gen.Dao) *physicalAssetCapabilityDo {
	p.DO = *do.(*gen.DO)
	return p
}
